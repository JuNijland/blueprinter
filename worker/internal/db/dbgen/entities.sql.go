// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entities.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEntitiesByWatch = `-- name: GetEntitiesByWatch :many
SELECT id, org_id, watch_id, schema_type, external_id, content, url, status, first_seen_at, last_seen_at, created_at, updated_at FROM entities
WHERE watch_id = $1 AND status = 'active'
ORDER BY external_id
`

func (q *Queries) GetEntitiesByWatch(ctx context.Context, watchID pgtype.UUID) ([]Entity, error) {
	rows, err := q.db.Query(ctx, getEntitiesByWatch, watchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.WatchID,
			&i.SchemaType,
			&i.ExternalID,
			&i.Content,
			&i.Url,
			&i.Status,
			&i.FirstSeenAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEntitiesStale = `-- name: MarkEntitiesStale :exec
UPDATE entities
SET status = 'stale', updated_at = now()
WHERE watch_id = $1 AND external_id = ANY($2::text[])
  AND status = 'active'
`

type MarkEntitiesStaleParams struct {
	WatchID pgtype.UUID `json:"watch_id"`
	Column2 []string    `json:"column_2"`
}

func (q *Queries) MarkEntitiesStale(ctx context.Context, arg MarkEntitiesStaleParams) error {
	_, err := q.db.Exec(ctx, markEntitiesStale, arg.WatchID, arg.Column2)
	return err
}

const upsertEntity = `-- name: UpsertEntity :one
INSERT INTO entities (org_id, watch_id, schema_type, external_id, content, url, status, first_seen_at, last_seen_at)
VALUES ($1, $2, $3, $4, $5, $6, 'active', now(), now())
ON CONFLICT (org_id, watch_id, schema_type, external_id) DO UPDATE
SET content = EXCLUDED.content,
    url = EXCLUDED.url,
    status = 'active',
    last_seen_at = now(),
    updated_at = now()
RETURNING id, org_id, watch_id, schema_type, external_id, content, url, status, first_seen_at, last_seen_at, created_at, updated_at
`

type UpsertEntityParams struct {
	OrgID      string      `json:"org_id"`
	WatchID    pgtype.UUID `json:"watch_id"`
	SchemaType string      `json:"schema_type"`
	ExternalID string      `json:"external_id"`
	Content    []byte      `json:"content"`
	Url        pgtype.Text `json:"url"`
}

func (q *Queries) UpsertEntity(ctx context.Context, arg UpsertEntityParams) (Entity, error) {
	row := q.db.QueryRow(ctx, upsertEntity,
		arg.OrgID,
		arg.WatchID,
		arg.SchemaType,
		arg.ExternalID,
		arg.Content,
		arg.Url,
	)
	var i Entity
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.WatchID,
		&i.SchemaType,
		&i.ExternalID,
		&i.Content,
		&i.Url,
		&i.Status,
		&i.FirstSeenAt,
		&i.LastSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
